# 实验报告

## 0 总览

### 0.1 设计的功能描述

（含所有实现的指令描述，以及单周期/流水线 CPU 频率）

1. 实现指令

   单周期与流水线 CPU 实现指令相同，为 24 条基础指令

2. 指令描述

| 单周期   |                                                            |
| -------- | ---------------------------------------------------------- |
| **R 型** |                                                            |
| add      | (rd) ← (rs1) + (rs2)                                       |
| sub      | (rd) ← (rs1) - (rs2)                                       |
| and      | (rd) ← (rs1) &  (rs2)                                      |
| or       | (rd) ← (rs1) \| (rs2)                                      |
| xor      | (rd) ← (rs1) ^ (rs2)                                       |
| sll      | (rd) ← (rs1) <<  (rs2)                                     |
| srl      | (rd) ← (rs1) >>  (rs2)，逻辑右移                           |
| sra      | (rd) ← (rs1) >>  (rs2)，算术右移                           |
| **I 型** |                                                            |
| addi     | (rd) ← (rs1) +  sext(imm)                                  |
| andi     | (rd) ← (rs1) &  sext(imm)                                  |
| ori      | (rd) ← (rs1) \|  sext(imm)                                 |
| xori     | (rd) ← (rs1) ^  sext(imm)                                  |
| slli     | (rd) ← (rs1) <<  shamt                                     |
| srli     | (rd) ← (rs1) >>  shamt，逻辑右移                           |
| srai     | (rd) ← (rs1) >>  shamt，算术右移                           |
| lw       | `(rd) ← sext(Mem[(rs1) + sext(offset)][31:0])`             |
| jalr     | t ← (pc) + 4；(pc) ← ((rs1) + sext(offset)) & ~1；(rd) ← t |
| **S 型** |                                                            |
| sw       | Mem[(rs1) + sext(offset)] ← (rs2)[31:0]                    |

| 多周期   |                                                            |
| -------- | ---------------------------------------------------------- |
| **R 型** |                                                            |
| add      | (rd) ← (rs1) + (rs2)                                       |
| sub      | (rd) ← (rs1) - (rs2)                                       |
| and      | (rd) ← (rs1) &  (rs2)                                      |
| or       | (rd) ← (rs1) \| (rs2)                                      |
| xor      | (rd) ← (rs1) ^ (rs2)                                       |
| sll      | (rd) ← (rs1) <<  (rs2)                                     |
| srl      | (rd) ← (rs1) >>  (rs2)，逻辑右移                           |
| sra      | (rd) ← (rs1) >>  (rs2)，算术右移                           |
| **I 型** |                                                            |
| addi     | (rd) ← (rs1) +  sext(imm)                                  |
| andi     | (rd) ← (rs1) &  sext(imm)                                  |
| ori      | (rd) ← (rs1) \|  sext(imm)                                 |
| xori     | (rd) ← (rs1) ^  sext(imm)                                  |
| slli     | (rd) ← (rs1) <<  shamt                                     |
| srli     | (rd) ← (rs1) >>  shamt, 逻辑右移                           |
| srai     | (rd) ← (rs1) >>  shamt, 算术右移                           |
| lw       | `(rd) ← sext(Mem[(rs1) + sext(offset)][31:0])`             |
| jalr     | t ← (pc) + 4；(pc) ← ((rs1) + sext(offset)) & ~1；(rd) ← t |
| **S 型** |                                                            |
| sw       | Mem[(rs1) + sext(offset)] ← (rs2)[31:0]                    |
| **B 型** |                                                            |
| beq      | if ((rs1) = (rs2)) (pc) ← (pc) + sext(offset)              |
| bne      | if ((rs1) ≠ (rs2)) (pc) ← (pc) + sext(offset)              |
| blt      | if ((rs1) < (rs2)) (pc) ← (pc) + sext(offset)，有符号比较  |
| bge      | if ((rs1) ≥ (rs2)) (pc) ← (pc) + sext(offset)，有符号比较  |
| **U 型** |                                                            |
| lui      | (rd) ← sext(imm[31:12]  << 12)                             |
| **J 型** |                                                            |
| jal      | (rd) ← (pc) + 4；(pc) ← (pc) + sext(offset)                |

### 0.2 设计的主要特色

（除基本要求以外的设计）

1. 分支预测功能：采用静态分支预测，默认不进行跳转。判断跳转在 EX 阶段，故而如果进行跳转，需要插入两条空指令。
2. 实现了结构清晰、可高度复用的总线外设：由于在设计时有意将 CPU、IROM、DRAM 分离，所以后续得到了很清晰的 IROM、CPU、BUS、DRAM、I/O 设备的结构，这样的结构使得代码能能够极为方便的复用和理解，并可适用于单周期和流水线的两个上板测试。

### 0.3 资源使用情况、功耗数据截图（实现后）

[0.3 资源使用情况、功耗数据截图（实现后）](0.3.md)

## 1 单周期 CPU 设计与实现

### 1.1 单周期 CPU 整体框图

（要求：无需画出模块内的逻辑，但要标出模块之间信号线的信号名和位宽，以 及说明每个模块的功能含义）

![单周期cpu数据通路](../_images/%E5%8D%95%E5%91%A8%E6%9C%9Fcpu%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF.png)

模块说明：

1. 取指模块
  - PC：更新当前 pc 值
  - NPC：得到下一条指令的 pc 值
  - IROM：指令存储器，根据 pc 值得到对应的指令
2. 译指/写回模块
- SEXT：立即数扩展单元，根据控制信号对指令中的立即数进行扩展

- RF：寄存器堆，可根据地址读出或写入对应寄存器数据
- MUX4_1：多路选择器，选择写入 RF 的数据
3. 执行模块
- MUX2_1：选择器，选择写入 ALU.B 端口的数据

- ALU：运算器，根据控制信号执行加、减、按位与、按位或、按位异或、逻辑右移、逻辑左移、算术右移运算
4. 存储模块
  - DRAM：数据存储器，用于存储数据
5. 控制模块
  - CONTROLLER：控制器，根据指令生成各个器件的控制信号

### 1.2 单周期 CPU 模块详细设计

（要求：各个模块的详细设计图，要包含内部的子模块，以及关键性逻辑，标出信号名和位宽，并有详细说明）

[1.2 单周期 CPU 模块详细设计](1.2.md)

### 1.3 单周期 CPU 仿真及结果分析

（要求：包含逻辑运算指令、访存指令、跳转指令的仿真截图，以及结果分析）

[1.3 单周期 CPU 仿真及结果分析](1.3.md)

## 2 流水线 CPU 设计与实现

### 2.1 流水线的划分

（要求：画出流水线的划分，并标明每个阶段 CPU 完成的功能）

1. 取指阶段（instruction fetch，简称 IF 阶段）

  （1） 更新 pc 值

  （2） 得到当前 pc 对应的指令

  （3） 可能会由于冒险检测器的控制信号而保持停顿

2. 译指阶段（instruction decode，简称 ID 阶段）

  （1）由控制器得到控制信号

  （2）得到寄存器堆中两个目标寄存器堆的值

  （3）得到对应类型的拓展的立即数

  （4）结合译指结果，在冒险检测器中判断当前是否需要数据前递以及停顿，并处理

3. 执行阶段（execute，简称 EX 阶段）

  （1）ALU 根据控制信号以及操作数执行对应的运算

  （2）根据控制信号和 ALU 计算结果判断是否跳转以及跳转的 pc 值，传达给 IF 阶段的 NPC

  （3）完成写回寄存器堆数据的第一次选择（处理）

4. 访存阶段（memory access，简称 MEM 阶段）

  （1）根据控制信号以及操作地址对存储器执行相应的访存操作

  （2）完成写回寄存器堆数据的第二次选择（处理）

5. 写回阶段（write back，简称 WB 阶段）

   根据控制信号向寄存器堆目标寄存器写入相应数据

### 2.2 流水线 CPU 整体框图

（要求：无需画出模块内的逻辑，但要标出模块之间信号线的信号名和位宽，以 及说明每个模块的功能含义）

![流水线cpu数据通路](../_images/%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF.svg)

模块说明：

1. 取指模块

  - PC：更新当前 pc 值
  - NPC：得到下一条指令的 pc 值
  - IROM：指令存储器，根据 pc 值得到对应的指令

2. 译指模块

- CONTROLLER：控制器，根据指令生成各个器件的控制信号

- SEXT：立即数扩展单元，根据控制信号对指令中的立即数进行扩展
- RF：寄存器堆，可根据地址读出或写入对应寄存器数据

3. 执行模块

- ALU_MUX：选择器，选择写入 ALU.B 端口的数据

- ALU：运算器，根据控制信号执行加、减、按位与、按位或、按位异或、逻辑右移、逻辑左移、算术右移运算
- NPC_CONTROL：根据控制信号和计算结果判断是否跳转以及跳转的 pc 值，传达给 NPC
- WD_MUX1：写回寄存器堆的数据 wD 的第一次选择

4. 存储模块

  - DRAM：数据存储器，用于存储数据
  - WD_MUX2：写回寄存器堆的数据 wD 的第二次选择

5. 流水线寄存器模块

- REG_IF_ID、REG_ID_EX、REG_EX_MEM、REG_MEM_WB：用于存储各阶段正在执行的指令信息

6. 冒险检测器模块

- HAZARD_DETECTION：检测并处理数据冒险与控制冒险：接收用于判断冒险的控制信号和数据，发出前递、停顿、清除的控制信号和相关数据

### 2.3 流水线 CPU 模块详细设计

（要求：各个模块的详细设计图，要包含内部的子模块，以及关键性逻辑，标出信号名和位宽，并有详细说明；数据冒险与控制冒险的解决方法必须要详细说明）

[2.3 流水线 CPU 模块详细设计](2.3.md)

### 2.4 流水线 CPU 仿真及结果分析

（要求：包含数据冒险、控制冒险的仿真截图，以及结果分析）

[2.4 流水线 CPU 仿真及结果分析](2.4.md)

## 3 设计过程中遇到的问题及解决方法

（包括设计过程中的错误及测试过程中遇到的问题）

- [3.1 ALU 模块设计的细微差别](3.1.md)
- [3.2 检测数据冒险的判断条件](3.2.md)

## 4 总结

（要求：个人收获以及对课程的建议）

- [4 总结](4.md)